{"name":"Sve documentation","tagline":"Various articles and documents about the Sve programming language","body":"# Sve language #\r\n\r\n## Variables and data types ##\r\n\r\nThere are five important datatypes in Sve: number, string, bool, table and function. Rare datatypes nfunction and userdata are not discussed in this document.\r\n\r\nNumber is floating pointer datatype and equivalent to Java's double. Strings are in UTF-8 format. Boolean constants are ```true``` and ```false```. ```nil``` is false.\r\n\r\nTables are complex data structures and have many features. They are basically hash maps. Keys are always strings, if a number is given it is converted to a string. Word **array** is used as a synonym to table.\r\n\r\n### Constants ###\r\n\r\n#### Number constants ####\r\n\r\nNumber constants are in decimal format. They can contain decimals (0.435) or be in sciencific format (like 0.435e34). ```Infinity``` and ```NaN``` are number constants.\r\n\r\n#### String constants ####\r\n\r\nStrings are in UTF-8 format. They can contain escaped characters Escape character is ```\\```.\r\n\r\nOne word string can also be in the key format: ```:key```.\r\n\r\n```ruby\r\n\"A normal string\"\r\n\r\n:key_format\r\n\r\n\"A\" == :A\r\n```\r\n\r\n#### Table values ####\r\n\r\nTable values can be either in **table format** or **list format**.\r\n```perl\r\n# table format\r\ntbl = { key = value, key1 = value2 }\r\n\r\n# list format\r\nlist = [value1, value2]\r\n```\r\nIn list format keys are given to variables. Value 1 gets key ```0```. Value 2 gets key ```1```.\r\n\r\n#### Boolean constants and the nil constant ####\r\n\r\nBoolean constants are ```true``` and ```false```. The nil constant, ```nil```, is a equivalent to null in Java or Javascript.\r\n\r\n### Declaring variables ###\r\n\r\nIn Sve, undefined variables are an error. To define a variable a value must be assigned to it.\r\n```ruby\r\nvar = value\r\n\r\ni = 3\r\nmsg = \"Hello world!\"\r\ncar = { topspeed=3, color=:red }\r\n```\r\n\r\nInside functions ```local``` keyword should be used when declaring new variables. If there is a variable of the same name on the top level, a value is assigned to it instead of declaring a new variable.\r\n\r\n```perl\r\ndef: myfunction() {\r\n    local msg = \"Hello world!\"\r\n    # ...\r\n}\r\n\r\n# without local keyword\r\nmsg = nil\r\ndef: setmsg(newmsg) {\r\n    msg = newmsg\r\n}\r\n```\r\n\r\n### Number increment and decrement statements ###\r\n\r\nShortcut syntaxes ```variable++``` and ```variable--``` increment and decrement number variables by one. Expression ```variable++``` returns the original value and ```+ +variable``` the incremented value.\r\n\r\n### Table accessing and modifying expressions ###\r\n\r\n```table[key]``` is the primary way to get a value from a table. Shortcut syntax ```table.key``` can be used and is equivalent to ```table[\"key\"]``` (similar to one in Lua).\r\n\r\nModifying a table is similar to modifying a variable.\r\n```perl\r\ntbl = { a=1, b=2 }\r\ntbl.a = 2\r\ntbl[\"b\"] = 3\r\n```\r\n\r\n## Statements and control structures ##\r\n\r\n### Semicolons ###\r\n\r\nSemicolons are not required, but can be used in order to prevent ambiguities. Programmer can decided whether to use semicolons or not.\r\n\r\nFollowing ambiguities are solved using semicolons:\r\n\r\n```ruby\r\n# a = b(c+d)->e\r\na = b\r\n;(c+d)->e\r\n\r\n# a = $$.b = c\r\na = $;\r\n$.b = c\r\n```\r\n\r\n### Blocks ###\r\n\r\nA block starts with ```{``` and ends with ```}```. A block is considered to be a single statement.\r\n\r\n### If ###\r\n\r\n```perl\r\nif: condition {\r\n    # action 1\r\n} else: {\r\n    # action 2\r\n}\r\n```\r\n\r\nIf condition evaluates to ```true```, the first action is executed. Otherwise the second action is executed. Else-block is optional.\r\n\r\n### While and For ###\r\n\r\nCode inside a while loop is executed as long as the condition is true.\r\n```perl\r\nwhile: condition {\r\n    # code\r\n}\r\n```\r\n\r\nCode inside a for loop is executed as long as the condition is true. Initialization is executed before the loop and incrementing is executed every time after the code is executed.\r\n```perl\r\nfor: initialization, condition, incrementation {\r\n    # code\r\n}\r\n```\r\nExample:\r\n```perl\r\nfor: local i = 0, i < 10, i++ {\r\n    print(i)\r\n}\r\n```\r\n\r\n## Functions ##\r\n\r\nFunctions are first class values in Sve. All functions are anonymous and can be assigned to a variables.\r\n\r\nA \"named\" function is declared using a shortcut syntax.\r\n```ruby\r\ndef: function_name(parameters) {\r\n    # code\r\n}\r\n```\r\nWhich is equivalent to:\r\n```ruby\r\nfunction_name = def(parameters) {\r\n    # code\r\n}\r\n```\r\n\r\nA value is returned using return keyword.\r\n```ruby\r\ndef: squaresum(value1, value2) {\r\n    return value1*value1 + value2*value2\r\n}\r\n```\r\n\r\nA shortcut syntax can be used for one line math functions.\r\n```ruby\r\ndef: squaresum(v1, v2) = v1*v1 + v2*v2\r\n```\r\n\r\n### Function calling ###\r\n\r\nThere are three function calling syntaxes. First, parentheses. ```function(args)```. Second, ```::```-operator: ```function::arg```, which is handy for printing text. Third, arrow operator: ```arg1->function(rest_of_arguments)```. Arrow resembles method calling and is sometimes used with conversion functions. ```20->ticks``` returns value of 20 seconds in ticks.\r\n\r\n```ruby\r\nprint(\"hello\")\r\nprint::\"hello\"\r\n\"hello\"->print\r\n\r\ntell(@m, \"hello\")\r\n@m->tell(\"hello\")\r\n\r\na=[1,2,3]\r\nlen(a)\r\na->len\r\n```\r\n\r\n## Important Sve functions ##\r\n\r\nFunction|Type|Description\r\nkeys(tbl)|\ttable -> table|\tReturns an array which contains all keys of table ```tbl```.\r\nlen(arr)|\ttable -> number|\t\tReturns the number of elements with a numerical key in array ```arr```. To get the size of a table, use ```len(tbl->keys)```.\r\nrnd(n)|\tnumber -> number|\tCreates a random number in range ```0..n-1```\r\ntype(obj)|\tany -> string|\tReturns the name of the type of ```obj```. (either ```bool```, ```function```, ```nil```, ```number``` or ```table```)\r\n\r\n\r\n### Sve function documentation ###\r\n\r\nThere are many sve functions, you can list all sve function help texts using function allhelp (from chat ```/sve allhelp()```). A single help text can be viewed using help function (from chat ```/sve help(\"function_name\")```).\r\n\r\n## Synthetic variables ##\r\n\r\n### Scope variables ###\r\n\r\nIn sve, scopes are tables that are used to store variables. There are two important scope variables: the global scope ($) and the local scope ($$). The global scope contains all variables that are declared at the top level. Not inside any block. The local scope contains all variables in the local (current) scope and all parent scopes including the global scope.\r\n\r\n```perl\r\nhello = \"hello world\"\r\nprint($[\"hello\"])  # -> \"hello world\" hello is declared at the top level\r\nprint($$[\"hello\"]) # -> \"hello world\" the local scope is the global scope in top level\r\n\r\ni = 1\r\n{\r\n    local i = 3 # local keyword is used to create a new variable, it is not required at the top level\r\n\r\n    print($[\"i\"])  # -> 1\r\n    print($$[\"i\"]) # -> 3\r\n}\r\n```\r\n\r\n### Modifying scopes ###\r\n\r\nScopes can be modified using these functions. Remember, scopes are tables and these function work with both tables and scopes.\r\n\r\nFunction|Type|Description\r\n--------|----|-----------\r\ndefine(scope, index, value)|table, string, any ->|Creates a new variable or modifies an existing in a specific scope. Super scopes are ignored. Can be compared to the local keyword.\r\nundefine(table, index)|table, string ->|Removes an entry from a table. Works with scopes too.\r\ndefined(table, index)|table, string -> bool|Returns true if table contains an index. Works with scopes too.\r\nsetsup(scope, scope)|table, table -> table|Sets the super scope of a scope.\r\ngetsup(scope)|table -> table|Returns the super scope of a scope.\r\nsetpt(scope, scope)|table, table -> table|Sets the prototype scope of a scope.\r\ngetpt(scope)|table ->  table|Returns the prototype scope of a scope.\r\nsetptf(scope, function)|table, function ->|Sets the prototype/index function of a scope.\r\ngetptf(scope)|table -> function|Returns the prototype/index function of a scope.\r\nsetls(function, scope)|function, table ->|Sets function declaration scope.\r\ngetls(function)|function -> table|Gets the declaration scope of a function.\r\n\r\nEvery table (and scope) has a super table. If an index is not found from the table, it is assumed to be in the super table. A prototype table is like the super table, except that it is read-only.\r\n\r\n```perl\r\ntbl = {}\r\nsup = {a=1, b=2}\r\nsetsup(tbl, sup)\r\n\r\nprint(tbl.a) # -> 1\r\nprint(sup.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\ntbl.a = 2\r\nprint(tbl.a) # -> 2\r\nprint(sup.a) # -> 2\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\n# ,\r\n\r\ntbl = {}\r\npt = {a=1, b=2}\r\nsetpt(tbl, pt)\r\n\r\nprint(tbl.a) # -> 1\r\nprint(pt.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\ntbl.a = 2\r\nprint(tbl.a) # -> 2\r\nprint(pt.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> true\r\n```\r\n\r\nPrototype function is called if an index is not found from super or prototype table. A prototype function takes the index as an argument ant returns it's value. A table which has a prototype function can't trigger an index not found exception.\r\n\r\n\r\n\r\n## Synthetic parameters ##\r\n\r\nGenerated parameters begin with character $. They can be accessed using scope variables.\r\n\r\nVariable|Using scope variable|Type|Description\r\n--------|--------------------|----|-----------\r\n$args|```$$[\"$args\"]```|table|An array of arguments\r\n$parent|```$$[\"$parent\"]```|scope|The scope which function is called from\r\n$obj|```$$[\"$obj\"]```|any|The object which contains the function, available only when function is called in style ```obj.function()``` in which case it contains ```obj```\r\n\r\n$parent can be used to modify caller's environment. For example, this removes $-characters from synthetic parameters:\r\n```perl\r\ndef: removedollar {\r\n    local parent = $$[\"$parent\"]\r\n    define(parent, \"parent\", parent[\"$parent\"]) # define-function is used in place of the local-keyword when modifying scopes\r\n    define(parent, \"args\", parent[\"$args\"])\r\n    if: defined(parent, \"$obj\") # $obj does not exist if function is called in a wrong way\r\n        define(parent, \"obj\", parent[\"$obj\"])\r\n}\r\n\r\ndef: printsynthetics {\r\n    removedollar()\r\n    print::keys(parent) # scope variable should not be printed\r\n    print::args\r\n    if: defined($$, \"obj\") print::obj\r\n}\r\n\r\n{\r\n    local i = 1\r\n    printsynthetics()\r\n}\r\n```\r\n\r\n# Sve for Bukkit #\r\n\r\n## Built-in functions ##\r\n\r\nFunction|Type|Description\r\n--------|----|-----------\r\nbroadcast(msg)|\tstring -> nil|\tBroadcasts a message\r\nprint(msg)|\tstring -> nil|\tSends a message to all players\r\ntell(player, msg)|\tplayer or string, string -> nil|\tSends a message to a player\r\ngive(player, itemid)|\tplayer or string, number -> nil|\tGives an item to the player\r\nexec(player, cmd)|\tplayer or string, string -> number|\tExecutes the command as a player\r\nsystem(cmd)|\tstring -> nil|\tExecutes the command\r\nhasperm(player, perm)|\tplayer or string, string -> boolean|\tDoes a player have a permission?\r\nplayers()|\t( ) -> table(player)|\tCurrent players on the server\r\nworlds()|\t( ) -> table(world)|\tCurrent worlds\r\nlocation(x, y, z, world)|\tnumber, number, number, world -> location|\tCreates a new org.bukkit.Location object\r\nvector(x, y, z)|\tnumber, number, number -> vector|\tCreates a new org.bukkit.util.Vector object\r\nregistereventhandler(event, handler)|\tstring, function -> nil|\tRegisters an event handler\r\ngetServer()|->server|Returns the server (org.bukkit.Bukkit)\r\n\r\n## Minecraft integration ##\r\n\r\nVariables @m, @a and @w and related functions players() and worlds() are used to get the current player (@m), all players on the server (@a) and all worlds (@w). @m is a players object, and @a and @w are arrays.\r\n\r\nMethods of Java objects can be accessed. For example, @m is a CraftPlayer object and contains all methods from org.bukkit.entity.Player. A list of these methods is found from bukkit api documentation ([[http://jd.bukkit.org/rb/apidocs/|here]]).\r\n\r\nAs Sve is a typeless language and does not support method overloading, method names contain also types of the parameters. Method sendMessage(String) is called in sve code sendMessage_String. To send a message to a player: ```@m.sendMessage_String(\"msg\")```. If method is not overloaded, it can be used also without type information.\r\n\r\n```perl\r\nif: len(@a) != 0 {\r\n    local player = @a[rnd(@a->len)] # random player\r\n    if: !player.isOnGround() {\r\n        player.sendMessage_String(\"Hey, do you fly?!\")\r\n    }\r\n}\r\n```\r\n\r\n### Java Interface functions ###\r\n\r\n**getClass(name)** returns a java.lang.class object. ```getClass(\"java.lang.Object\")``` returns the same object as ```java.lang.Object.class``` in java.\r\n\r\n**static(name)** returns a table that contains all static fields (including enum constants) of a class. ```static(\"java.lang.Math\")``` returns a table that contains constants ```E``` and ```PI```.\r\n\r\nIt is recommended to \"import\" enums at the begin of a svefile:\r\n```perl\r\nmaterial = static(\"org.bukkit.Material\")\r\n\r\n# ...\r\n\r\nblock_material = material.STONE\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}