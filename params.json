{"name":"Sve documentation","tagline":"Various articles and documents about the Sve programming language","body":"# Introduction\r\n\r\nWhen I was younger I hosted Minecraft servers. I never liked playing Minecraft alone and I was the only one in my folk who was capable of hosting servers. Minecraft is an interesting game, and, as a programmer, I quicly learned how to mod it. I even created my own clone of the Minecraft classic server. But, when the number of players on my server quicly growed, we decided eventually to swich to [Bukkit](bukkit.org), a mod that adds a powerful plugin system to the official software.\r\n\r\nBukkit was buggy and plugins never worked together perfectly. I had difficulties with modding, as the plugin framework was limited and I never enjoyed creating new projects and packaging them. I wanted an easy way to change a mod without work, pain or restarting. I simply wanted to program. That is when I remembered Sve.\r\n\r\nSve is a simple language I invented several years before. It had almost no standard functions, and its syntax were weird. I redesigned it, created a standard library and built [a Bukkit plugin](dev.bukkit.org/bukkit-plugins/sve) around it. I programmed some minigames (for example Flappy Steve, a flappy bird clone and Lavasion, a worm-dodging game) and developed the language at the same time. Sve was a huge success on my server.\r\n\r\nBecause the main way to test functions was via Minecraft chat commands, Sve has some special syntax which was introduced to make writing one-line code easier. `->` operator, for example, is one of those. It was too hard to add a function call to the begin of the line and the end of the line.\r\n\r\nAs the Bukkit project has now died, there is no way to use Sve in the Minecraft world no longer. Nothing, however, stops me from implementing Sve for some other platforms, when I want. A scripting language is good to have.\r\n\r\nâ€“ Fergusq, the author of the Sve language\r\n\r\n# Sve language \r\n\r\n## Variables and data types \r\n\r\nThere are five important datatypes in Sve: number, string, bool, table and function. Rare datatypes nfunction and userdata are not discussed in this document.\r\n\r\nNumber is floating pointer datatype and equivalent to Java's double. Strings are in UTF-8 format. Boolean constants are `true` and `false`. `nil` is false.\r\n\r\nTables are complex data structures and have many features. They are basically hash maps. Keys are always strings, if a number is given it is converted to a string. Word **array** is used as a synonym to table.\r\n\r\n### Constants \r\n\r\n#### Number constants \r\n\r\nNumber constants are in decimal format. They can contain decimals (0.435) or be in sciencific format (like 0.435e34). `Infinity` and `NaN` are number constants.\r\n\r\n#### String constants \r\n\r\nStrings are in UTF-8 format. They can contain escaped characters Escape character is `\\`.\r\n\r\nOne word string can also be in the key format: `:key`.\r\n\r\n```ruby\r\n\"A normal string\"\r\n\r\n:key_format\r\n\r\n\"A\" == :A\r\n```\r\n\r\n#### Table values \r\n\r\nTable values can be either in **table format** or **list format**.\r\n```perl\r\n# table format\r\ntbl = { key = value, key1 = value2 }\r\n\r\n# list format\r\nlist = [value1, value2]\r\n```\r\nIn list format keys are given to variables. Value 1 gets key `0`. Value 2 gets key `1`.\r\n\r\n#### Boolean constants and the nil constant \r\n\r\nBoolean constants are `true` and `false`. The nil constant, `nil`, is a equivalent to null in Java or Javascript.\r\n\r\n### Declaring variables \r\n\r\nIn Sve, undefined variables are an error. To define a variable a value must be assigned to it.\r\n```ruby\r\nvar = value\r\n\r\ni = 3\r\nmsg = \"Hello world!\"\r\ncar = { topspeed=3, color=:red }\r\n```\r\n\r\nInside functions `local` keyword should be used when declaring new variables. If there is a variable of the same name on the top level, a value is assigned to it instead of declaring a new variable.\r\n\r\n```perl\r\ndef: myfunction() {\r\n    local msg = \"Hello world!\"\r\n    # ...\r\n}\r\n\r\n# without local keyword\r\nmsg = nil\r\ndef: setmsg(newmsg) {\r\n    msg = newmsg\r\n}\r\n```\r\n\r\n### Number increment and decrement statements \r\n\r\nShortcut syntaxes `variable++` and `variable--` increment and decrement number variables by one. Expression `variable++` returns the original value and `++variable` the incremented value.\r\n\r\n### Table accessing and modifying expressions \r\n\r\n`table[key]` is the primary way to get a value from a table. Shortcut syntax `table.key` can be used and is equivalent to `table[\"key\"]` (similar to one in Lua).\r\n\r\nModifying a table is similar to modifying a variable.\r\n```perl\r\ntbl = { a=1, b=2 }\r\ntbl.a = 2\r\ntbl[\"b\"] = 3\r\n```\r\n\r\n## Statements and control structures \r\n\r\n### Semicolons \r\n\r\nSemicolons are not required, but can be used in order to prevent ambiguities. Programmer can decided whether to use semicolons or not.\r\n\r\nFollowing ambiguities are solved using semicolons:\r\n\r\n```ruby\r\n# a = b(c+d)->e\r\na = b\r\n;(c+d)->e\r\n\r\n# a = $$.b = c\r\na = $;\r\n$.b = c\r\n```\r\n\r\n### Blocks \r\n\r\nA block starts with `{` and ends with `}`. A block is considered to be a single statement.\r\n\r\n### If \r\n\r\n```perl\r\nif: condition {\r\n    # action 1\r\n} else: {\r\n    # action 2\r\n}\r\n```\r\n\r\nIf condition evaluates to `true`, the first action is executed. Otherwise the second action is executed. Else-block is optional.\r\n\r\n### While and For \r\n\r\nCode inside a while loop is executed as long as the condition is true.\r\n```perl\r\nwhile: condition {\r\n    # code\r\n}\r\n```\r\n\r\nCode inside a for loop is executed as long as the condition is true. Initialization is executed before the loop and incrementing is executed every time after the code is executed.\r\n```perl\r\nfor: initialization, condition, incrementation {\r\n    # code\r\n}\r\n```\r\nExample:\r\n```perl\r\nfor: local i = 0, i < 10, i++ {\r\n    print(i)\r\n}\r\n```\r\n\r\n## Functions \r\n\r\nFunctions are first class values in Sve. All functions are anonymous and can be assigned to a variables.\r\n\r\nA \"named\" function is declared using a shortcut syntax.\r\n```ruby\r\ndef: function_name(parameters) {\r\n    # code\r\n}\r\n```\r\nWhich is equivalent to:\r\n```ruby\r\nfunction_name = def(parameters) {\r\n    # code\r\n}\r\n```\r\n\r\nA value is returned using return keyword.\r\n```ruby\r\ndef: squaresum(value1, value2) {\r\n    return value1*value1 + value2*value2\r\n}\r\n```\r\n\r\nA shortcut syntax can be used for one line math functions.\r\n```ruby\r\ndef: squaresum(v1, v2) = v1*v1 + v2*v2\r\n```\r\n\r\n### Function calling \r\n\r\nThere are three function calling syntaxes. First, parentheses. `function(args)`. Second, `::`-operator: `function::arg`, which is handy for printing text. Third, arrow operator: `arg1->function(rest_of_arguments)`. Arrow resembles method calling and is sometimes used with conversion functions. `20->ticks` returns value of 20 seconds in ticks.\r\n\r\n```ruby\r\nprint(\"hello\")\r\nprint::\"hello\"\r\n\"hello\"->print\r\n\r\ntell(@m, \"hello\")\r\n@m->tell(\"hello\")\r\n\r\na=[1,2,3]\r\nlen(a)\r\na->len\r\n```\r\n\r\n## Important Sve functions \r\n\r\nFunction|Type|Description\r\n--------|----|-----------\r\nkeys(tbl)|\ttable -> table|\tReturns an array which contains all keys of table `tbl`.\r\nlen(arr)|\ttable -> number|\t\tReturns the number of elements with a numerical key in array `arr`. To get the size of a table, use `len(tbl->keys)`.\r\nrnd(n)|\tnumber -> number|\tCreates a random number in range `0..n-1`\r\ntype(obj)|\tany -> string|\tReturns the name of the type of `obj`. (either `bool`, `function`, `nil`, `number` or `table`)\r\n\r\n\r\n### Sve function documentation \r\n\r\nThere are many sve functions, you can list all sve function help texts using function allhelp (from chat `/sve allhelp()`). A single help text can be viewed using help function (from chat `/sve help(\"function_name\")`).\r\n\r\n## Synthetic variables \r\n\r\n### Scope variables \r\n\r\nIn sve, scopes are tables that are used to store variables. There are two important scope variables: the global scope ($) and the local scope ($$). The global scope contains all variables that are declared at the top level. Not inside any block. The local scope contains all variables in the local (current) scope and all parent scopes including the global scope.\r\n\r\n```perl\r\nhello = \"hello world\"\r\nprint($[\"hello\"])  # -> \"hello world\" hello is declared at the top level\r\nprint($$[\"hello\"]) # -> \"hello world\" the local scope is the global scope in top level\r\n\r\ni = 1\r\n{\r\n    local i = 3 # local keyword is used to create a new variable, it is not required at the top level\r\n\r\n    print($[\"i\"])  # -> 1\r\n    print($$[\"i\"]) # -> 3\r\n}\r\n```\r\n\r\n### Modifying scopes \r\n\r\nScopes can be modified using these functions. Remember, scopes are tables and these function work with both tables and scopes.\r\n\r\nFunction|Type|Description\r\n--------|----|-----------\r\ndefine(scope, index, value)|table, string, any ->|Creates a new variable or modifies an existing in a specific scope. Super scopes are ignored. Can be compared to the local keyword.\r\nundefine(table, index)|table, string ->|Removes an entry from a table. Works with scopes too.\r\ndefined(table, index)|table, string -> bool|Returns true if table contains an index. Works with scopes too.\r\nsetsup(scope, scope)|table, table -> table|Sets the super scope of a scope.\r\ngetsup(scope)|table -> table|Returns the super scope of a scope.\r\nsetpt(scope, scope)|table, table -> table|Sets the prototype scope of a scope.\r\ngetpt(scope)|table ->  table|Returns the prototype scope of a scope.\r\nsetptf(scope, function)|table, function ->|Sets the prototype/index function of a scope.\r\ngetptf(scope)|table -> function|Returns the prototype/index function of a scope.\r\nsetls(function, scope)|function, table ->|Sets function declaration scope.\r\ngetls(function)|function -> table|Gets the declaration scope of a function.\r\n\r\nEvery table (and scope) has a super table. If an index is not found from the table, it is assumed to be in the super table. A prototype table is like the super table, except that it is read-only.\r\n\r\n```perl\r\ntbl = {}\r\nsup = {a=1, b=2}\r\nsetsup(tbl, sup)\r\n\r\nprint(tbl.a) # -> 1\r\nprint(sup.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\ntbl.a = 2\r\nprint(tbl.a) # -> 2\r\nprint(sup.a) # -> 2\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\n# ,\r\n\r\ntbl = {}\r\npt = {a=1, b=2}\r\nsetpt(tbl, pt)\r\n\r\nprint(tbl.a) # -> 1\r\nprint(pt.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> false\r\n\r\ntbl.a = 2\r\nprint(tbl.a) # -> 2\r\nprint(pt.a) # -> 1\r\nprint(defined(tbl, \"a\")) # -> true\r\n```\r\n\r\nPrototype function is called if an index is not found from super or prototype table. A prototype function takes the index as an argument ant returns it's value. A table which has a prototype function can't trigger an index not found exception.\r\n\r\n\r\n\r\n## Synthetic parameters \r\n\r\nGenerated parameters begin with character $. They can be accessed using scope variables.\r\n\r\nVariable|Using scope variable|Type|Description\r\n--------|--------------------|----|-----------\r\n$args|`$$[\"$args\"]`|table|An array of arguments\r\n$parent|`$$[\"$parent\"]`|scope|The scope which function is called from\r\n$obj|`$$[\"$obj\"]`|any|The object which contains the function, available only when function is called in style `obj.function()` in which case it contains `obj`\r\n\r\n$parent can be used to modify caller's environment. For example, this removes $-characters from synthetic parameters:\r\n```perl\r\ndef: removedollar {\r\n    local parent = $$[\"$parent\"]\r\n    define(parent, \"parent\", parent[\"$parent\"]) # define-function is used in place of the local-keyword when modifying scopes\r\n    define(parent, \"args\", parent[\"$args\"])\r\n    if: defined(parent, \"$obj\") # $obj does not exist if function is called in a wrong way\r\n        define(parent, \"obj\", parent[\"$obj\"])\r\n}\r\n\r\ndef: printsynthetics {\r\n    removedollar()\r\n    print::keys(parent) # scope variable should not be printed\r\n    print::args\r\n    if: defined($$, \"obj\") print::obj\r\n}\r\n\r\n{\r\n    local i = 1\r\n    printsynthetics()\r\n}\r\n```\r\n\r\n## Naming conventions\r\n\r\n### Case rules\r\n\r\n- The general rule: all names are in the **lowercase**. For example `print`, `string`, `endvote`.\r\n- All constants are in the `UPPER_CASE`.\r\n- All Java names are as in Java. For example `getClass`, `getServer`.\r\n\r\n### Other rules\r\n\r\n- All public constants must have the name their svefile as a prefix. For example `VOTE_PREFIX`, `FLY_MAXTURN`.\r\n- All generated variables have an @ sign as a prefix. For example `@a`, `@m`.\r\n- All generated parameters have a $ sign as a prefix. For example `$$[\"$args\"]`, `$$[\"$parent\"]`.\r\n\r\n### Program name\r\n\r\n- The name of a sveprogram should be short and descriptive, one word long. It should be prefixed with \"sve\". For example, a program that protects things should be named \"sveprotection\".\r\n- All permissions should begin with the name of the program. Eg. \"sveprotection.protect\".\r\n- The name of a svefile should end with \".sve\". Eg. \"protection.sve\".\r\n- If the program contains only one file, the actual file name should contain author's name to avoid name collisions. Eg. \"fergusq-protection.sve\"\r\n- If the program contains many svefiles, they should be all stored to a folder which is named after the program. Eg. \"fergusq-sveprotection\"\r\n- The event group of the program should be named after the file name. Eg. \"protection.sve\".\r\n- All public constants should begin with the name of the file. Eg. \"`PROTECTION_RANGE`\".\r\n\r\n## Namespaces and subfunctions\r\n\r\nBecause names in sve are supposed to be short, there is a great probability that two names are the same. The best ways to avoid name collisions is using namespaces and subfunctions.\r\n\r\n### Namespaces\r\n\r\nA namespace is a table which contains functions and variables.\r\n\r\n```ruby\r\n# create a new namespace 'protection'\r\nprotection = {}\r\n# adding variables to a namespace\r\nprotection.range = 2\r\nprotection.areas = []\r\n# functions\r\n{\r\n    def: protection.protectarea(area) {\r\n        if: type(area) == :string\r\n        area = areas[area]\r\n    }\r\n\r\n    setsup(protection, $)\r\n    setsup($$, protection) # makes variables and functions of protection usable without 'protection.' prefix\r\n}\r\n```\r\n\r\n### Subfunctions\r\n\r\nSubfunctions are functions which can be only accessed inside one function.\r\n\r\n```ruby\r\ndef: f1 {\r\n    def: f2 {\r\n        # ...\r\n    }\r\n    # ...\r\n    f2()\r\n}\r\n```\r\n\r\n# Sve libraries\r\n\r\n## Sve Standard Library\r\n\r\n### Foreach function\r\n\r\nForeach is a handy function provided by the svefile library. Foreach uses the maybe most powerful feature of the sve language: anonymous functions.\r\nUsing foreach is easy. Give it an array and an anonymous function and â€“ tah dah â€“ it works.\r\n```perl\r\nforeach(array)::def (element) { code }\r\n```\r\n\r\nExample: send a message to all players:\r\n\r\n```perl\r\nforeach(@a)::def(player) { player->tell(\"Hi!\") }\r\n```\r\n\r\n#### How does it work?\r\n\r\nIt can be hard to understand how foreach works. Here is it's source code:\r\n\r\n```ruby\r\ndef: foreach (t, u)\r\n    if: !u return def (u)\r\n        foreach(t, u)\r\n    else: {\r\n        local l = len(t)\r\n        for: local i=0,\r\n             i < l,\r\n             i++\r\n            u(t[i]) }\r\n```\r\n\r\nThe type of the foreach function the type notation is ##table(T) -> ((T -> ()) -> ())##. In other words, it takes and array and returns a function, which takes an anonymous function which takes an element of the array. The returned function calls foreach again with two arguments, the second is the callback function.\r\n\r\nForeach can be called with two arguments and that's a perfectly valid way. But the implementation provides us a more powerfui version, a one that generates functions which perform the operation. This can be used to easily create derivate functions, below are few examples:\r\n\r\n```perl\r\n# iterate thru range\r\ndef: iteraterange(start, stop) = foreach(range(start, stop))\r\n\r\n# for all players\r\ndef: forall(f) foreach(@a)::f\r\n\r\nforall::def (p) {\r\n    p->tell(\"hey!\")\r\n}\r\n```\r\n\r\n\r\n## Java Interface Library \r\n\r\n**getClass(name)** returns a java.lang.class object. `getClass(\"java.lang.Object\")` returns the same object as `java.lang.Object.class` in java.\r\n\r\n**static(name)** returns a table that contains all static fields (including enum constants) of a class. `static(\"java.lang.Math\")` returns a table that contains constants `E` and `PI`.\r\n\r\nIt is recommended to \"import\" enums at the begin of a svefile:\r\n```perl\r\nmaterial = static(\"org.bukkit.Material\")\r\n\r\n# ...\r\n\r\nblock_material = material.STONE\r\n```\r\n\r\n## Sve for Bukkit \r\n\r\n### Built-in functions \r\n\r\nFunction|Type|Description\r\n--------|----|-----------\r\nbroadcast(msg)|\tstring -> nil|\tBroadcasts a message\r\nprint(msg)|\tstring -> nil|\tSends a message to all players\r\ntell(player, msg)|\tplayer or string, string -> nil|\tSends a message to a player\r\ngive(player, itemid)|\tplayer or string, number -> nil|\tGives an item to the player\r\nexec(player, cmd)|\tplayer or string, string -> number|\tExecutes the command as a player\r\nsystem(cmd)|\tstring -> nil|\tExecutes the command\r\nhasperm(player, perm)|\tplayer or string, string -> boolean|\tDoes a player have a permission?\r\nplayers()|\t( ) -> table(player)|\tCurrent players on the server\r\nworlds()|\t( ) -> table(world)|\tCurrent worlds\r\nlocation(x, y, z, world)|\tnumber, number, number, world -> location|\tCreates a new org.bukkit.Location object\r\nvector(x, y, z)|\tnumber, number, number -> vector|\tCreates a new org.bukkit.util.Vector object\r\nregistereventhandler(event, handler)|\tstring, function -> nil|\tRegisters an event handler\r\ngetServer()|->server|Returns the server (org.bukkit.Bukkit)\r\n\r\n### Minecraft integration \r\n\r\nVariables @m, @a and @w and related functions players() and worlds() are used to get the current player (@m), all players on the server (@a) and all worlds (@w). @m is a players object, and @a and @w are arrays.\r\n\r\nMethods of Java objects can be accessed. For example, @m is a CraftPlayer object and contains all methods from org.bukkit.entity.Player. A list of these methods is found from bukkit api documentation ([[http://jd.bukkit.org/rb/apidocs/|here]]).\r\n\r\nAs Sve is a typeless language and does not support method overloading, method names contain also types of the parameters. Method sendMessage(String) is called in sve code sendMessage_String. To send a message to a player: `@m.sendMessage_String(\"msg\")`. If method is not overloaded, it can be used also without type information.\r\n\r\n```perl\r\nif: len(@a) != 0 {\r\n    local player = @a[rnd(@a->len)] # random player\r\n    if: !player.isOnGround() {\r\n        player.sendMessage_String(\"Hey, do you fly?!\")\r\n    }\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}